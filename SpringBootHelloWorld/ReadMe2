==> CrudRepository is a Spring data interface and to use it we need to create our interface by extending 
    CrudRepository. Spring provides CrudRepository implementation class automatically at runtime. 
    It contains methods such as save, findById, delete, count etc. Spring boot automatically detects our 
    repository if the package of that repository interface is the same or sub-package of the class annotated 
    with @SpringBootApplication.
    
==>    Spring boot uses spring-boot-starter-data-jpa starter to configure spring JPA
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
==> If we choose a package for our repository that is neither same package nor sub-package of the package of 
    the class annotated with @SpringBootApplication, then Spring boot will not be able to detect repository 
    classes by default. In this case we need to use @EnableJpaRepositories annotation with @SpringBootApplication.
    Using @EnableJpaRepositories we will configure package name in which our repository classes reside. 
    Suppose the package of our repository classes is com.cp.repository, we will use @EnableJpaRepositories as 
    following.
    			package com.concretepage;

				@SpringBootApplication
				@EnableJpaRepositories("com.cp.repository")
				public class MyApplication {  
							------
				}
				
==>  Custom Repository Methods
    CrudRepository provides methods for generic CRUD operation and if we want to add custom methods 
    in our interface that has extended CrudRepository, we can add in following ways. 

a. We can start our query method names with find...By, read...By, query...By, count...By, and get...By. 
   Before By we can add expression such as Distinct. After By we need to add property names of our entity. 
b. To get data on the basis of more than one property we can concatenate property names using And and Or while 
   creating method names. 
c. If we want to use completely custom name for our method, we can use @Query annotation to write query. 

		public interface ArticleRepository extends CrudRepository<Article, Long>  {
    		List<Article> findByTitle(String title);
    		List<Article> findDistinctByCategory(String category);
    		List<Article> findByTitleAndCategory(String title, String category);

    		@Query("SELECT a FROM Article a WHERE a.title=:title and a.category=:category")
    		List<Article> fetchArticles(@Param("title") String title, @Param("category") String category);
} 
    
==> MongoRepository is the sub class of CrudReposiotry which is used with MongoDB

==> @Field tag is used to provide different names to the keys in the documents (Just as we used @column with Mysql)

==> If we tag @Id in the bean class, then it will be saved in db with _Id and @Field tag will be overlooked
    But if we don't provide @Id tag, then _Id key is generated automatically.
    
==> While persisting into database, default constructor is MUST. So if you write parameterized constructor
    , then it is must to write a default constructor , else it will throw exception
    
==> @PersistenceConstructor : It is used to mark the constructor which is to be used for creating entities when 
    fetching data from the Mongo Server.
    When both constructors(default & parameterized) are present, then default constructor is called. But in case
    we want Parameterized constructor to be called at the time of creating entities after fetching data from the 
    database, we must annotate the parameterized constructor with @PersistenceConstructor
    i.e. in cae of a GET request, @PersistenceConstructor is called in case present
    
